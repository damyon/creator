// Vertex Shader GLSL code
        const vsSource = `
            attribute vec4 a_position;
            attribute vec2 a_texCoord;

            uniform mat4 u_matrix; // Model-view-projection matrix
            uniform float u_time;   // Time uniform for animation

            varying vec2 v_texCoord;

            void main() {
                // Ripple parameters - adjust these to change the ripple appearance
                float rippleStrength = 0.015; // How strong the ripples are (amplitude)
                float rippleSpeed = 5.0;     // How fast the ripples move
                float rippleFrequency = 15.0; // How many ripples (density)

                // Calculate an offset based on a sine wave
                // The ripple origin is effectively at the center of the texture (0.5, 0.5)
                vec2 center = vec2(0.5, 0.5);
                float dist = distance(a_texCoord, center); // Distance from current texCoord to center
                // Generate a sine wave based on distance and time
                float offset = sin(dist * rippleFrequency + u_time * rippleSpeed) * rippleStrength;

                // Apply the offset to the texture coordinates
                // We add the offset in the direction from the center to the current texCoord
                vec2 distortedTexCoord = a_texCoord + normalize(a_texCoord - center) * offset;

                v_texCoord = distortedTexCoord; // Pass distorted UVs to fragment shader
                gl_Position = u_matrix * a_position; // Transform vertex position
            }
        `;

        // Fragment Shader GLSL code
        const fsSource = `
            precision mediump float; // Set default precision for floats

            uniform sampler2D u_texture; // The texture of the surface (e.g., water)
            uniform vec3 u_lightColor;   // Color of a light source
            uniform vec3 u_ambientColor; // Ambient light color

            varying vec2 v_texCoord; // Interpolated distorted texture coordinates from vertex shader

            void main() {
                // Sample the texture at the distorted UV coordinates
                vec4 texColor = texture2D(u_texture, v_texCoord);

                // --- Basic Lighting Simulation (Optional, can be improved) ---
                // This creates a "specular" highlight that moves with the ripples
                // For true reflections/refractions, more advanced techniques are needed.

                // Assume a flat surface normal initially
                vec3 normal = vec3(0.0, 0.0, 1.0);

                // A simple way to make the "specular" highlight appear to ripple
                // This creates a wave-like pattern for the light intensity
                float rippleEffect = sin(v_texCoord.x * 20.0 + u_time * 3.0) * sin(v_texCoord.y * 20.0 + u_time * 3.0) * 0.5 + 0.5;

                // Example light direction (from top-right-front)
                vec3 lightDirection = normalize(vec3(0.5, 0.8, -0.7));

                // Diffuse lighting component
                float diff = max(dot(normal, lightDirection), 0.0); // Max with 0 to avoid negative light
                vec3 diffuse = u_lightColor * texColor.rgb * diff;

                // Simple specular highlight for a "shiny" effect on ripples
                // This is a very basic approximation.
                vec3 viewDirection = normalize(vec3(0.0, 0.0, 1.0)); // Assume camera looking straight down
                vec3 halfVector = normalize(lightDirection + viewDirection); // Halfway vector for Blinn-Phong
                float spec = pow(max(dot(normal, halfVector), 0.0), 32.0) * rippleEffect; // Adjust shininess (32.0)
                vec3 specular = u_lightColor * spec;

                // Combine ambient, diffuse, and specular components
                vec3 finalColor = (texColor.rgb * u_ambientColor) + diffuse + specular;

                // Set the final fragment color, preserving original texture's alpha
                gl_FragColor = vec4(finalColor, texColor.a);
            }
        `;
